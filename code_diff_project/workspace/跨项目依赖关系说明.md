# 跨项目依赖关系说明

## 项目结构

- **common-api**: 共享的 DTO 和接口定义
- **service-a**: 用户服务和订单服务
- **service-b**: 通知服务

## 跨项目依赖关系

### 1. common-api 被其他项目引用

#### 共享的 DTO 类：
- `OrderDTO` - 订单数据传输对象
  - 被 service-a 的 `OrderController`、`OrderServiceImpl` 使用
  - 被 service-b 的 `UserClient`、`NotificationService` 使用

- `UserDTO` - 用户数据传输对象
  - 被 service-a 的 `UserController`、`UserServiceImpl`、`NotificationClient` 使用
  - 被 service-b 的 `UserClient`、`NotificationService`、`NotificationController` 使用

#### 共享的 Service 接口：
- `UserService` - 用户服务接口
  - 被 service-a 的 `UserServiceImpl` 实现
  
- `OrderService` - 订单服务接口
  - 被 service-a 的 `OrderServiceImpl` 实现

### 2. service-a → service-b 的调用

#### NotificationClient (service-a 调用 service-b)
位置: `service-a/src/main/java/com/example/servicea/client/NotificationClient.java`

**调用的 service-b 接口：**
1. `POST /api/notifications/welcome`
   - 方法: `sendWelcomeEmail(UserDTO user)`
   - 说明: 发送欢迎邮件
   - 被调用位置: `UserServiceImpl.createUser()`

2. `POST /api/notifications/send?message={message}`
   - 方法: `sendNotification(UserDTO user, String message)`
   - 说明: 发送通知消息
   - 被调用位置: 
     - `OrderServiceImpl.createOrder()` - 创建订单后发送通知
     - `OrderServiceImpl.updateOrderStatus()` - 订单状态变更后发送通知
     - `UserServiceImpl.updateUser()` - 用户信息更新后发送通知
     - `UserServiceImpl.updateUserStatus()` - 用户状态变更后发送通知
     - `UserServiceImpl.deleteUser()` - 删除用户前发送通知

### 3. service-b → service-a 的调用

#### UserClient (service-b 调用 service-a)
位置: `service-b/src/main/java/com/example/serviceb/client/UserClient.java`

**调用的 service-a 接口：**
1. `GET /api/users/{userId}`
   - 方法: `getUserById(Long userId)`
   - 说明: 获取用户信息
   - 被调用位置:
     - `NotificationService.sendEmailNotification()` - 验证用户是否存在
     - `NotificationService.sendBulkNotification()` - 获取用户信息
     - `NotificationService.sendOrderNotification(Long orderId)` - 获取用户信息

2. `POST /api/users?username={username}&email={email}`
   - 方法: `createUser(String username, String email)`
   - 说明: 创建用户

3. `GET /api/orders/{orderId}`
   - 方法: `getOrderById(Long orderId)`
   - 说明: 获取订单信息
   - 被调用位置:
     - `NotificationService.sendOrderNotification(Long orderId)` - 获取订单信息

4. 辅助方法: `userExists(Long userId)`
   - 说明: 验证用户是否存在
   - 被调用位置:
     - `NotificationService.sendEmailNotification()` - 验证用户
     - `NotificationService.sendBatchNotifications()` - 批量验证用户

## API 接口清单

### service-a 提供的 API

#### UserController (`/api/users`)
- `POST /api/users` - 创建用户
  - 参数: username, email
  - 返回: UserDTO
  - 内部调用: `NotificationClient.sendWelcomeEmail()` → service-b
  
- `GET /api/users/{userId}` - 获取用户 ⭐ 被 service-b 调用
  - 参数: userId
  - 返回: UserDTO
  
- `GET /api/users` - 获取所有用户
  - 返回: List<UserDTO>
  
- `PUT /api/users/{userId}` - 更新用户
  - 参数: userId, UserDTO
  - 返回: boolean
  - 内部调用: `NotificationClient.sendNotification()` → service-b
  
- `DELETE /api/users/{userId}` - 删除用户
  - 参数: userId
  - 返回: boolean
  - 内部调用: `NotificationClient.sendNotification()` → service-b

#### OrderController (`/api/orders`)
- `POST /api/orders` - 创建订单
  - 参数: userId, productName, amount
  - 返回: OrderDTO
  - 内部调用: `NotificationClient.sendNotification()` → service-b
  
- `GET /api/orders/{orderId}` - 获取订单 ⭐ 被 service-b 调用
  - 参数: orderId
  - 返回: OrderDTO
  
- `GET /api/orders/user/{userId}` - 获取用户订单列表
  - 参数: userId
  - 返回: List<OrderDTO>
  
- `PUT /api/orders/{orderId}/status` - 更新订单状态
  - 参数: orderId, status
  - 返回: boolean
  - 内部调用: `NotificationClient.sendNotification()` → service-b
  
- `DELETE /api/orders/{orderId}` - 取消订单
  - 参数: orderId
  - 返回: boolean
  - 内部调用: `NotificationClient.sendNotification()` → service-b

### service-b 提供的 API

#### NotificationController (`/api/notifications`)
- `POST /api/notifications/welcome` - 发送欢迎邮件 ⭐ 被 service-a 调用
  - 参数: UserDTO
  - 返回: String
  - 内部调用: `UserClient.userExists()` → service-a
  
- `POST /api/notifications/send` - 发送通知 ⭐ 被 service-a 调用
  - 参数: UserDTO, message
  - 返回: String
  - 内部调用: `UserClient.userExists()` → service-a
  
- `POST /api/notifications/order` - 发送订单通知
  - 参数: userId, orderNumber
  - 返回: String
  - 内部调用: `UserClient.getUserById()` → service-a
  
- `POST /api/notifications/batch` - 批量发送通知
  - 参数: List<UserDTO>, message
  - 返回: String
  - 内部调用: `UserClient.userExists()` → service-a

## 依赖流程示例

### 示例 1: 创建用户流程（跨项目调用）
```
1. 客户端 → service-a: POST /api/users?username=alice&email=alice@example.com
2. service-a (UserController.createUser)
   └─ UserServiceImpl.createUser()
      ├─ 创建用户对象
      └─ 调用 NotificationClient.sendWelcomeEmail(user)
         └─ service-a → service-b: POST /api/notifications/welcome
            └─ service-b (NotificationController.sendWelcomeEmail)
               └─ NotificationService.sendWelcomeEmail()
                  └─ NotificationService.sendEmailNotification()
                     ├─ 调用 UserClient.userExists(userId)
                     │  └─ service-b → service-a: GET /api/users/{userId}
                     └─ 发送欢迎邮件
```

### 示例 2: 创建订单流程（跨项目调用）
```
1. 客户端 → service-a: POST /api/orders?userId=1&productName=Laptop&amount=999.99
2. service-a (OrderController.createOrder)
   └─ OrderServiceImpl.createOrder()
      ├─ 创建订单对象
      ├─ 调用 UserServiceImpl.getUserById(userId) 获取用户信息
      └─ 调用 NotificationClient.sendNotification(user, message)
         └─ service-a → service-b: POST /api/notifications/send?message=...
            └─ service-b (NotificationController.sendNotification)
               └─ NotificationService.sendNotification()
                  └─ NotificationService.sendEmailNotification()
                     ├─ 调用 UserClient.userExists(userId)
                     │  └─ service-b → service-a: GET /api/users/{userId}
                     └─ 发送订单确认邮件
```

### 示例 3: 更新订单状态流程（跨项目调用）
```
1. 客户端 → service-a: PUT /api/orders/123/status?status=1
2. service-a (OrderController.updateStatus)
   └─ OrderServiceImpl.updateOrderStatus()
      ├─ 获取订单信息
      ├─ 更新订单状态
      ├─ 调用 UserServiceImpl.getUserById() 获取用户信息
      └─ 调用 NotificationClient.sendNotification(user, message)
         └─ service-a → service-b: POST /api/notifications/send?message=...
            └─ service-b (NotificationController.sendNotification)
               └─ NotificationService.sendNotification()
                  └─ NotificationService.sendEmailNotification()
                     ├─ 调用 UserClient.userExists(userId)
                     │  └─ service-b → service-a: GET /api/users/{userId}
                     └─ 发送状态更新通知
```

### 示例 4: 批量发送通知流程（跨项目调用）
```
1. 客户端 → service-b: POST /api/notifications/batch
2. service-b (NotificationController.sendBatchNotifications)
   └─ NotificationService.sendBatchNotifications()
      └─ 遍历每个用户
         ├─ 调用 UserClient.userExists(userId)
         │  └─ service-b → service-a: GET /api/users/{userId}
         └─ 发送通知邮件
```

## 测试建议

### 测试跨项目依赖分析

#### 1. 修改 common-api 的 OrderDTO
**修改内容**: 添加新字段 `deliveryAddress` 或修改 `totalAmount` 字段类型
```java
private String deliveryAddress; // 新增字段
```

**预期影响**:
- service-a:
  - `OrderController.createOrder()` - 使用 OrderDTO
  - `OrderController.getOrder()` - 返回 OrderDTO
  - `OrderServiceImpl.createOrder()` - 创建 OrderDTO
  - `OrderServiceImpl.getOrderById()` - 返回 OrderDTO
  
- service-b:
  - `UserClient.getOrderById()` - 返回 OrderDTO
  - `NotificationService.sendOrderNotification()` - 使用 OrderDTO

#### 2. 修改 common-api 的 UserDTO
**修改内容**: 添加新字段 `address` 或修改 `email` 字段验证规则
```java
private String address; // 新增字段
```

**预期影响**:
- service-a:
  - `UserController` 的所有方法
  - `UserServiceImpl` 的所有方法
  - `NotificationClient.sendWelcomeEmail()` - 参数使用 UserDTO
  - `NotificationClient.sendNotification()` - 参数使用 UserDTO
  
- service-b:
  - `NotificationController` 的所有方法
  - `NotificationService` 的所有方法
  - `UserClient.getUserById()` - 返回 UserDTO
  - `UserClient.createUser()` - 返回 UserDTO

#### 3. 修改 service-a 的 UserController
**修改内容**: 修改 `GET /api/users/{userId}` 接口的返回值结构
```java
// 修改前
public UserDTO getUser(@PathVariable Long userId)

// 修改后
public Map<String, Object> getUser(@PathVariable Long userId)
```

**预期影响**:
- service-b:
  - `UserClient.getUserById()` - 调用此接口，返回类型不匹配
  - `NotificationService.sendEmailNotification()` - 间接受影响
  - `NotificationService.sendBulkNotification()` - 间接受影响
  - `NotificationService.sendOrderNotification()` - 间接受影响

#### 4. 修改 service-b 的 NotificationController
**修改内容**: 修改 `POST /api/notifications/send` 接口的参数
```java
// 修改前
public String sendNotification(@RequestBody UserDTO user, @RequestParam String message)

// 修改后
public String sendNotification(@RequestBody UserDTO user, @RequestParam String message, @RequestParam String priority)
```

**预期影响**:
- service-a:
  - `NotificationClient.sendNotification()` - 调用此接口，参数不匹配
  - `OrderServiceImpl.createOrder()` - 间接受影响
  - `OrderServiceImpl.updateOrderStatus()` - 间接受影响
  - `UserServiceImpl.updateUser()` - 间接受影响
  - `UserServiceImpl.updateUserStatus()` - 间接受影响
  - `UserServiceImpl.deleteUser()` - 间接受影响

#### 5. 修改 service-a 的 OrderServiceImpl
**修改内容**: 修改 `createOrder` 方法的逻辑，增加对 NotificationClient 的调用
```java
// 在 createOrder 方法中增加额外的通知调用
notificationClient.sendWelcomeEmail(user); // 新增调用
```

**预期影响**:
- 应该检测到对 `NotificationClient.sendWelcomeEmail()` 的新调用
- 应该追踪到 service-b 的 `NotificationController.sendWelcomeEmail()` 接口

#### 6. 修改 service-b 的 NotificationService
**修改内容**: 修改 `sendOrderNotification` 方法，增加对 UserClient 的调用
```java
// 在 sendOrderNotification 方法中增加额外的用户验证
boolean exists = userClient.userExists(userId); // 新增调用
```

**预期影响**:
- 应该检测到对 `UserClient.userExists()` 的新调用
- 应该追踪到 service-a 的 `UserController.getUser()` 接口

## 关键文件列表

### common-api
- `src/main/java/com/example/common/dto/OrderDTO.java` ⭐ 被两个项目使用
- `src/main/java/com/example/common/dto/UserDTO.java` ⭐ 被两个项目使用
- `src/main/java/com/example/common/service/UserService.java` - 接口定义
- `src/main/java/com/example/common/service/OrderService.java` - 接口定义

### service-a
- `src/main/java/com/example/servicea/controller/UserController.java` ⭐ 提供 API 给 service-b
- `src/main/java/com/example/servicea/controller/OrderController.java` ⭐ 提供 API 给 service-b
- `src/main/java/com/example/servicea/service/UserServiceImpl.java` - 实现 UserService，调用 NotificationClient
- `src/main/java/com/example/servicea/service/OrderServiceImpl.java` - 实现 OrderService，调用 NotificationClient
- `src/main/java/com/example/servicea/client/NotificationClient.java` ⭐ 调用 service-b 的 API

### service-b
- `src/main/java/com/example/serviceb/controller/NotificationController.java` ⭐ 提供 API 给 service-a
- `src/main/java/com/example/serviceb/service/NotificationService.java` - 调用 UserClient
- `src/main/java/com/example/serviceb/client/UserClient.java` ⭐ 调用 service-a 的 API

## 跨项目依赖总结

### service-a 依赖 service-b
- **调用方**: `NotificationClient`
- **被调用方**: `NotificationController`
- **调用场景**:
  1. 创建用户后发送欢迎邮件
  2. 创建订单后发送订单确认通知
  3. 更新订单状态后发送状态变更通知
  4. 更新用户信息后发送更新通知
  5. 更新用户状态后发送状态变更通知
  6. 删除用户前发送删除通知

### service-b 依赖 service-a
- **调用方**: `UserClient`
- **被调用方**: `UserController` 和 `OrderController`
- **调用场景**:
  1. 发送通知前验证用户是否存在
  2. 获取用户详细信息用于发送通知
  3. 获取订单信息用于发送订单通知
  4. 批量发送通知时验证每个用户

### 双向依赖关系
```
service-a ←→ service-b
    ↓           ↓
common-api (共享 DTO 和接口)
```

这种双向依赖关系形成了一个完整的微服务调用链，非常适合测试跨项目依赖分析功能。
